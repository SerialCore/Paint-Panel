using Microsoft.Graphics.Canvas;
using System;
using System.Threading.Tasks;
using Windows.Foundation;
using Windows.Storage;
using Windows.Storage.Streams;
using Windows.UI;
using Windows.UI.Xaml.Controls;

// The Collection of functions to save and open ink files or image files.

namespace Paint_Panel
{
    class FilesOperator
    {

        // the image just generated by simple InkStroke object without background
        public async void generateImage(StorageFile file, InkCanvas inkCanvas)
        {
            CanvasDevice device = CanvasDevice.GetSharedDevice();
            CanvasRenderTarget renderTarget = new CanvasRenderTarget(device, (int)inkCanvas.ActualWidth, (int)inkCanvas.ActualHeight, 300);

            using (var ds = renderTarget.CreateDrawingSession())
            {
                ds.DrawInk(inkCanvas.InkPresenter.StrokeContainer.GetStrokes());
            }
            using (var fileStream = await file.OpenAsync(FileAccessMode.ReadWrite))
            {
                await renderTarget.SaveAsync(fileStream, CanvasBitmapFileFormat.Png, 1f);
            }
        }

        // the image just generated by simple InkStroke object
        public async void generateImage(StorageFile file, InkCanvas inkCanvas, Color color)
        {
            CanvasDevice device = CanvasDevice.GetSharedDevice();
            CanvasRenderTarget renderTarget = new CanvasRenderTarget(device, (int)inkCanvas.ActualWidth, (int)inkCanvas.ActualHeight, 300);

            using (var ds = renderTarget.CreateDrawingSession())
            {
                // 图片的背景色
                ds.Clear(color);
                ds.DrawInk(inkCanvas.InkPresenter.StrokeContainer.GetStrokes());
            }
            using (var fileStream = await file.OpenAsync(FileAccessMode.ReadWrite))
            {
                await renderTarget.SaveAsync(fileStream, CanvasBitmapFileFormat.Png, 1f);
            }
        }

        // the inkCanvas-size-image generated by InkStroke object and inserted image
        public async void generateImage(StorageFile file, InkCanvas inkCanvas, Image back_image, Color color, IRandomAccessStream x)
        {
            CanvasDevice device = CanvasDevice.GetSharedDevice();
            //CanvasBitmap image = await CanvasBitmap.LoadAsync(device, x);
            CanvasRenderTarget renderTarget = new CanvasRenderTarget(device, (int)inkCanvas.ActualWidth, (int)inkCanvas.ActualHeight, 300);

            using (var ds = renderTarget.CreateDrawingSession())
            {
                CanvasBitmap img = await CanvasBitmap.LoadAsync(renderTarget, x);
                Rect rect = new Rect(((int)inkCanvas.ActualWidth - (int)back_image.ActualWidth) / 2,
                    ((int)inkCanvas.ActualHeight - (int)back_image.ActualHeight) / 2,
                    (int)back_image.ActualWidth,
                    (int)back_image.ActualHeight);
                ds.Clear(color);
                ds.DrawImage(img, rect);
                ds.DrawInk(inkCanvas.InkPresenter.StrokeContainer.GetStrokes());
            }
            using (var fileStream = await file.OpenAsync(FileAccessMode.ReadWrite))
            {
                await renderTarget.SaveAsync(fileStream, CanvasBitmapFileFormat.Png, 1f);
            }
        }

        // the image just generated by simple InkStroke object without background
        public async Task<StorageFile> returnImage(StorageFile file, InkCanvas inkCanvas)
        {
            CanvasDevice device = CanvasDevice.GetSharedDevice();
            CanvasRenderTarget renderTarget = new CanvasRenderTarget(device, (int)inkCanvas.ActualWidth, (int)inkCanvas.ActualHeight, 300);

            using (var ds = renderTarget.CreateDrawingSession())
            {
                ds.DrawInk(inkCanvas.InkPresenter.StrokeContainer.GetStrokes());
            }
            using (var fileStream = await file.OpenAsync(FileAccessMode.ReadWrite))
            {
                await renderTarget.SaveAsync(fileStream, CanvasBitmapFileFormat.Png, 1f);
            }
            return file;
        }

        // the image just generated by simple InkStroke object
        public async Task<StorageFile> returnImage(StorageFile file, InkCanvas inkCanvas, Color color)
        {
            CanvasDevice device = CanvasDevice.GetSharedDevice();
            CanvasRenderTarget renderTarget = new CanvasRenderTarget(device, (int)inkCanvas.ActualWidth, (int)inkCanvas.ActualHeight, 300);

            using (var ds = renderTarget.CreateDrawingSession())
            {
                // 图片的背景色
                ds.Clear(color);
                ds.DrawInk(inkCanvas.InkPresenter.StrokeContainer.GetStrokes());
            }
            using (var fileStream = await file.OpenAsync(FileAccessMode.ReadWrite))
            {
                await renderTarget.SaveAsync(fileStream, CanvasBitmapFileFormat.Png, 1f);
            }
            return file;
        }

        // the inkCanvas-size-image generated by InkStroke object and inserted image
        public async Task<StorageFile> returnImage(StorageFile file, InkCanvas inkCanvas, Image back_image, Color color, IRandomAccessStream x)
        {
            CanvasDevice device = CanvasDevice.GetSharedDevice();
            //CanvasBitmap image = await CanvasBitmap.LoadAsync(device, x);
            CanvasRenderTarget renderTarget = new CanvasRenderTarget(device, (int)inkCanvas.ActualWidth, (int)inkCanvas.ActualHeight, 300);

            using (var ds = renderTarget.CreateDrawingSession())
            {
                CanvasBitmap img = await CanvasBitmap.LoadAsync(renderTarget, x);
                Rect rect = new Rect(((int)inkCanvas.ActualWidth - (int)back_image.ActualWidth) / 2,
                    ((int)inkCanvas.ActualHeight - (int)back_image.ActualHeight) / 2,
                    (int)back_image.ActualWidth,
                    (int)back_image.ActualHeight);
                ds.Clear(color);
                ds.DrawImage(img, rect);
                ds.DrawInk(inkCanvas.InkPresenter.StrokeContainer.GetStrokes());
            }
            using (var fileStream = await file.OpenAsync(FileAccessMode.ReadWrite))
            {
                await renderTarget.SaveAsync(fileStream, CanvasBitmapFileFormat.Png, 1f);
            }
            return file;
        }
    }
}
